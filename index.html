<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Under Maintenance | My Portfolio</title>
    
    <link rel="stylesheet" href="style.css">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
    <div class="maintenance-container">
        
        <div class="background-glow"></div>
        <div class="dots top-left"></div>
        <div class="dots bottom-right"></div>
        
        <div class="card-stack">
            <div class="content-card">
                
                <div class="image-wrapper">
                    <div class="image-inner">
                        <img src="pp.jpg" alt="Md. Arafat Hossain Faisal" class="profile-image">
                    </div>
                </div>
                
                <h1 class="title">UNDER MAINTENANCE</h1>
                
                <p class="typewriter">My Portfolio is getting a futuristic upgrade. Be back soon!</p>
            </div>
        </div>
    </div>

<script>
// Continuous subtle float + parallax/tilt based on mouse movement
(function() {
    const wrapper = document.querySelector('.image-wrapper');
    if (!wrapper) return;

    let targetTX = 0, targetTY = 0, targetRX = 0, targetRY = 0;
    let curTX = 0, curTY = 0, curRX = 0, curRY = 0;
    let t = 0; // time for autonomous motion

    const clamp = (n, min, max) => Math.max(min, Math.min(max, n));

    function onMove(x, y) {
        const dx = (x / window.innerWidth) * 2 - 1;   // -1..1
        const dy = (y / window.innerHeight) * 2 - 1;  // -1..1
        const strength = 10; // translation in px
        const tilt = 6;      // rotation in deg
        targetTX = clamp(dx * strength, -strength, strength);
        targetTY = clamp(dy * strength, -strength, strength);
        targetRY = clamp(-dx * tilt, -tilt, tilt);
        targetRX = clamp(dy * tilt, -tilt, tilt);
    }

    window.addEventListener('mousemove', (e) => onMove(e.clientX, e.clientY), { passive: true });
    window.addEventListener('mouseleave', () => { targetTX = targetTY = targetRX = targetRY = 0; });

    function tick() {
        t += 0.015;
        const ease = 0.08;
        // Easing towards mouse targets
        curTX += (targetTX - curTX) * ease;
        curTY += (targetTY - curTY) * ease;
        curRX += (targetRX - curRX) * ease;
        curRY += (targetRY - curRY) * ease;

        // Autonomous subtle motion even without mouse
        const floatX = Math.cos(t * 0.8) * 2.5; // px
        const floatY = Math.sin(t) * 4;         // px
        const tiltX  = Math.sin(t * 0.6) * 2;   // deg
        const tiltY  = Math.cos(t * 0.6) * 2;   // deg

        const tx = (curTX + floatX).toFixed(2);
        const ty = (curTY + floatY).toFixed(2);
        const rx = (curRX + tiltX).toFixed(2);
        const ry = (curRY + tiltY).toFixed(2);

        wrapper.style.transform = `translate3d(${tx}px, ${ty}px, 0) rotateX(${rx}deg) rotateY(${ry}deg)`;
        requestAnimationFrame(tick);
    }
    tick();
})();

// Create blurred ghost copy under the card (before typewriter so ghost participates)
(function() {
    const stack = document.querySelector('.card-stack');
    const card = stack && stack.querySelector('.content-card');
    if (!stack || !card) return;
    const ghost = card.cloneNode(true);
    ghost.classList.add('ghost');
    ghost.setAttribute('aria-hidden', 'true');
    stack.appendChild(ghost);
})();

// Typewriter effect for all subtitle elements (retypes every 10s)
(function() {
    let els = Array.from(document.querySelectorAll('.typewriter'));
    if (!els.length) return;
    const full = (els[0].getAttribute('data-text') || els[0].textContent).trim();
    const typeSpeed = 40; // ms per character
    const cycleDelay = 10000; // 10 seconds between re-typing

    function typeOnce() {
        return new Promise(resolve => {
            // Clear all before typing
            els.forEach(e => e.textContent = '');
            let i = 0;
            function step() {
                if (i <= full.length) {
                    const slice = full.slice(0, i);
                    els.forEach(e => e.textContent = slice);
                    i++;
                    setTimeout(step, typeSpeed);
                } else {
                    resolve();
                }
            }
            step();
        });
    }

    async function run() {
        while (true) {
            // Refresh elements in case DOM changed
            els = Array.from(document.querySelectorAll('.typewriter'));
            await typeOnce();
            await new Promise(r => setTimeout(r, cycleDelay));
        }
    }
    run();
})();
</script>
</body>
</html>